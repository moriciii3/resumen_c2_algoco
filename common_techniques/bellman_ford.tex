% common_techniques/bellman_ford.tex

\subsubsection{Algoritmo de Bellman-Ford (Caminos Mínimos con Ciclos Negativos)}

Bellman-Ford encuentra los caminos más cortos desde un nodo fuente único ($s$) a todos los demás en un grafo dirigido y ponderado. Es el único algoritmo de fuente única que funciona correctamente con \textbf{aristas de peso negativo}. Su principal fortaleza es la capacidad de \textbf{detectar y encontrar ciclos de peso negativo}.

\paragraph{Contexto de Ejercicio Típico (Detección de Arbitraje):}
Dado un conjunto de monedas y tasas de cambio (donde las tasas pueden representarse como logaritmos negativos de los pesos de las aristas), determine si existe una secuencia de transacciones que le permita terminar con más dinero del que empezó (un \textbf{ciclo de arbitraje} o \textbf{ciclo negativo}).

\paragraph{Estrategia:}
El algoritmo relaja todas las aristas $V-1$ veces. Este número de iteraciones garantiza que se encuentre el camino más corto, asumiendo que no hay ciclos negativos. Una iteración $V$ adicional se usa para detectar la presencia de un \textbf{ciclo de peso negativo}. 

\paragraph{Recurrencia (Relajación):}
Para cada arista $(u, v)$ con peso $w$:
$$\text{dist}[v] = \min(\text{dist}[v], \text{dist}[u] + w)$$

\paragraph{Detección de Ciclos:}
Si en la $V$-ésima iteración la distancia de algún nodo $\text{dist}[v]$ se sigue actualizando, existe un ciclo negativo alcanzable. El código localiza un nodo dentro de este ciclo para reconstruirlo.

\paragraph{Complejidad:}
* \textbf{Tiempo:} $O(V \cdot E)$, donde $V$ es el número de vértices y $E$ es el número de aristas.
* \textbf{Espacio:} $O(V)$ para almacenar distancias y predecesores.

% --- Código C++ (Tipado simplificado) ---
\subsubsection{Código C++ (Bellman-Ford)}
\begin{lstlisting}[
	caption={Implementación de Bellman-Ford con detección y reconstrucción de ciclo negativo, JAIME INOSTROZA MI DIOS},
	extendedchars=true, 
	literate={ñ}{{\~n}}1 {Ñ}{{\~N}}1 {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
	]
	#include<bits/stdc++.h>
	using namespace std;
	
	#define int long long // Usamos long long para distancias para prevenir overflow
	using ll = long long;
	
	struct BellmanFord {  
		struct Edge { int from, to, weight; };  
		int n, last_updated = -1; 
		const int INF = 1e9 + 7; // INF simplificado a int
		
		vector<int> p;
		vector<ll> dist; // Mantener ll para distancias/pesos acumulados
		
		BellmanFord(vector<Edge> &G, int s, int nn) {    
			n = nn; 
			dist.assign(n+2, INF);    
			p.assign(n+2, -1); 
			dist[s] = 0;    
			
			for (int i = 1; i <= n; i++) {      
				last_updated = -1;      
				for (Edge &e : G)        
				if (dist[e.from] != INF && dist[e.from] + e.weight < dist[e.to]) {          
					dist[e.to] = dist[e.from] + e.weight;          
					p[e.to] = e.from; 
					last_updated = e.to;        
				}    
			}  
		}  
		
		bool getCycle(vector<int> &cycle) {    
			if (last_updated == -1) return false;
			
			// Moverse V veces para entrar en el ciclo
			for (int i = 0; i < n; i++) // Cambiado a 'n' iteraciones por seguridad
			last_updated = p[last_updated];
			
			// Reconstruir el ciclo
			for (int x = last_updated ;; x = p[x]) {
				cycle.push_back(x);
				if (x == last_updated && cycle.size() > 1) break;
			}
			reverse(cycle.begin(), cycle.end());
			return true;  
		}
	};  
	
	void solve(){
		int n, m;
		cin >> n >> m;
		vector<BellmanFord::Edge> G;
		for(int i = 0; i < m; i++){
			int u, v, w;
			cin >> u >> v >> w;
			G.push_back({u,v,w});
		}
		
		// Suponemos que el nodo fuente es 1
		BellmanFord mish(G, 1, n); 
		
		vector<int> ans;
		if(mish.getCycle(ans)){
			cout << "YES " << endl;
			for(auto x: ans){
				cout << x << " ";
			}
			cout << endl;
		} else{
			cout << "NO" << endl;
		}
	} 
	
	signed main(){
		solve();
		return 0;
	}
\end{lstlisting}