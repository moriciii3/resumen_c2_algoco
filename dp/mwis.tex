% dp/mwis.tex

\subsubsection{Maximum Weight Independent Set (MWIS) en Grafo de Camino}

El problema MWIS en un **grafo de camino** busca encontrar un subconjunto de vértices (elementos de un array $A$) tal que **ningún par de vértices sea adyacente** y la suma de sus pesos (valores) sea \textbf{máxima}.

\paragraph{Fórmula DP:}
Sea $DP[i]$ el peso máximo del conjunto independiente usando los elementos de $A$ hasta el índice $i$.
$$DP[i] = \max( DP[i-1], A[i] + DP[i-2])$$

\paragraph{Reconstrucción:}
La función \texttt{wisReconstruction} determina qué elementos fueron incluidos en el conjunto óptimo, yendo de atrás hacia adelante ($i = n-1$). En cada paso, se compara si el valor máximo $DP[i]$ vino de \textbf{no tomar} $A[i]$ ($DP[i-1]$) o de \textbf{tomar} $A[i]$ ($A[i] + DP[i-2]$).

\paragraph{Complejidad:}
* \textbf{Tiempo:} $O(N)$ (un único bucle lineal para el cálculo de DP y otro para la reconstrucción).
* \textbf{Espacio:} $O(N)$ (para el array de DP).

% --- Código C++ ---
\subsubsection{Código C++ (MWIS con Reconstrucción)}
\begin{lstlisting}[
	caption={Maximum Weight Independent Set (MWIS) con Reconstrucción},
	extendedchars=true, 
	literate={ñ}{{\~n}}1 {Ñ}{{\~N}}1 {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
	]
	#include <bits/stdc++.h>
	using namespace std;
	# define int long long
	
	vector<int> wisReconstruction(vector<int>& A){
		int n = A.size();
		if (n == 0) return {};
		if (n == 1) return {0};
		
		vector<int> dp(n);
		dp[0] = A[0];
		dp[1] = max(A[0], A[1]);
		
		for (int i = 2; i < n; i++){
			dp[i] = max(dp[i-1], A[i] + dp[i-2]);
		}
		
		// Reconstrucción correcta
		vector<int> S;
		int i = n - 1;
		
		while (i >= 1){
			if (dp[i-1] >= A[i] + (i >= 2 ? dp[i-2] : 0)){
				i = i - 1;     // no tomo i
			} else {
				S.push_back(i); // tomo i
				i = i - 2;
			}
		}
		
		if (i == 0){
			S.push_back(0);
		}
		
		// opcional: invertir para tenerlos en orden natural
		reverse(S.begin(), S.end());
		
		return S;
	}
	
	int mwis(vector<int>& A){
		int n = A.size();
		if (n == 0) return 0;
		if (n == 1) return A[0];
		vector<int> dp(n);
		
		dp[0] = A[0];
		dp[1] = max(A[0], A[1]);
		
		for (int i = 2; i < n; i++){
			dp[i] = max(dp[i-1], A[i] + dp[i-2]);
		}
		
		return dp[n-1];
	}
	
	
	signed main(){
		vector<int> values = {1,2,4,1,7,8,3};
		cout << mwis(values) << endl;
		
		vector<int> res = wisReconstruction(values);
		for (auto n: res){
			cout << n << " ";
		}
	}
\end{lstlisting}