% greedy/kruskal.tex

\subsubsection{Algoritmo de Kruskal (Árbol de Expansión Mínima - MST)}

El Algoritmo de Kruskal es un método \textbf{Greedy} que encuentra un subconjunto de aristas que conecta todos los vértices de un grafo con el \textbf{menor peso total posible} sin formar ciclos.

\paragraph{Implementación Clave:}
Esta implementación se centra en el \textbf{MST} utilizando la estructura \texttt{union\_find} para la detección eficiente de ciclos. La función \texttt{minSpanningTree} recibe la lista de aristas y el número de nodos ($N$), y retorna el costo total del MST y la lista de aristas seleccionadas. Es importante notar que la entrada de nodos se convierte de 1-based a 0-based en el \texttt{main}.

\paragraph{Estrategia:}
1.  \textbf{Ordenar:} Ordenar todas las aristas por peso de forma ascendente (\texttt{custom\_compare\_min}).
2.  \textbf{Seleccionar:} Iterar sobre las aristas, seleccionando solo aquellas que unen dos componentes disjuntas (no formando ciclos).

\paragraph{Complejidad:}
* \textbf{Tiempo:} $O(E \log E + E \cdot \alpha(V))$, donde $E$ es el número de aristas y $\alpha(V)$ es la función inversa de Ackermann (dominada por la ordenación $E \log E$).
* \textbf{Espacio:} $O(V + E)$ (para la estructura Union-Find y las aristas).

% --- Código C++ (Tal cual) ---
\subsubsection{Código C++ (Kruskal - MST)}
\begin{lstlisting}[
	caption={Algoritmo de Kruskal para MST con manejo de entrada N/M},
	extendedchars=true, 
	literate={ñ}{{\~n}}1 {Ñ}{{\~N}}1 {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
	]
	#include <bits/stdc++.h>
	using namespace std;
	
	struct Edge{
		int n1;
		int n2;
		int w;
	};
	
	bool custom_compare_min(Edge a, Edge b){
		return a.w < b.w;
	}
	
	struct union_find{
		vector<int> e;
		union_find(int n) {e.assign(n, -1);}
		
		int findSet(int x){
			return (e[x] < 0 ? x : e[x] = findSet(e[x]));
		}
		
		bool sameSet(int x, int y) {return findSet(x) == findSet(y);}
		
		int size(int x){return -e[findSet(x)];}
		
		bool unionSet(int x, int y){
			x = findSet(x), y = findSet(y);
			if (x == y) return 0;
			if (e[x] > e[y]) swap(x,y);
			e[x] += e[y];
			e[y] = x;
			return 1;
		}
	};
	
	// N := "Cantidad de nodos" ,,,, M := "Cantidad de aristas" 
	pair<int, vector<pair<int,int>>> minSpanningTree(vector<Edge> &v, int n){
		sort(v.begin(), v.end(), custom_compare_min);
		union_find sets(n);
		vector<pair<int,int>> output;
		
		int contador = 0;
		
		for (int i = 0; i < v.size(); i++){
			Edge nodo = v[i];
			if (sets.sameSet(nodo.n1, nodo.n2) == false){
				sets.unionSet(nodo.n1, nodo.n2);
				output.push_back({nodo.n1+1, nodo.n2+1});
				contador += nodo.w;
				if (output.size() == n-1) break;
			}
		}
		
		sort(output.begin(), output.end());
		
		return {contador, output};
	}
	
	int main() {
		int N,M;
		cin >> N >> M;
		vector<Edge> v;
		
		for (int i = 0; i < M; i++){
			int a, b, p;
			cin >> a >> b >> p;
			
			Edge nodo;
			// Los nodos deben empezar en cero
			nodo.n1 = a-1;
			nodo.n2 = b-1;
			nodo.w = p;
			v.push_back(nodo);
		}
		
		cout << minSpanningTree(v, N).first << endl;
		
		return 0;
	}
\end{lstlisting}