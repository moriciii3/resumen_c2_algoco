% greedy/kruskal.tex

\subsubsection{Algoritmo de Kruskal (MST y MaxST)}

El Algoritmo de Kruskal encuentra el \textbf{Árbol de Expansión Mínima (MST)} en un grafo ponderado no dirigido. El mismo algoritmo, invirtiendo el orden de las aristas (de mayor a menor peso), encuentra el \textbf{Árbol de Expansión Máxima (MaxST)}. Ambos son algoritmos \textbf{Greedy} porque en cada paso seleccionan la arista localmente óptima (la de menor o mayor peso) que no forma un ciclo.

\paragraph{Estructura Clave:}
El código utiliza la estructura de conjuntos disjuntos \texttt{union\_find} para detectar ciclos de manera eficiente.

\paragraph{Estrategia:}
\begin{enumerate}
	\item \textbf{MST (\texttt{minSpanningTree}):} Ordena las aristas por peso de forma ascendente.
	\item \textbf{MaxST (\texttt{maxSpanningTree}):} Ordena las aristas por peso de forma descendente.
	\item \textbf{Selección:} En ambos casos, se seleccionan las aristas en el orden establecido siempre que conecten dos componentes previamente disjuntas (no formando ciclos).
\end{enumerate}

\paragraph{Complejidad:}
* \textbf{Tiempo:} $O(E \log E + E \cdot \alpha(V))$, donde $E$ es el número de aristas y $\alpha(V)$ es la función inversa de Ackermann. El término $E \log E$ domina debido a la ordenación.
* \textbf{Espacio:} $O(V + E)$ (para almacenar el grafo y la estructura Union-Find).

% --- Código C++ (Tal cual) ---
\subsubsection{Código C++ (Kruskal - MST y MaxST)}
\begin{lstlisting}[
	caption={Algoritmo de Kruskal (MST y MaxST) usando Union-Find},
	extendedchars=true, 
	literate={ñ}{{\~n}}1 {Ñ}{{\~N}}1 {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
	]
	#include <bits/stdc++.h>
	using namespace std;
	
	# define ll long long
	# define ld long double
	# define endl '\n'
	
	struct Edge{
		int n1;
		int n2;
		int w;
	};
	
	bool custom_compare_min(Edge a, Edge b){
		return a.w < b.w;
	}
	
	bool custom_compare_max(Edge a, Edge b){
		return a.w > b.w;
	}
	
	struct union_find{
		vector<int> e;
		union_find(int n) {e.assign(n, -1);}
		
		int findSet(int x){
			return (e[x] < 0 ? x : e[x] = findSet(e[x]));
		}
		
		bool sameSet(int x, int y) {return findSet(x) == findSet(y);}
		
		int size(int x){return -e[findSet(x)];}
		
		bool unionSet(int x, int y){
			x = findSet(x), y = findSet(y);
			if (x == y) return 0;
			if (e[x] > e[y]) swap(x,y);
			e[x] += e[y];
			e[y] = x;
			return 1;
		}
	};
	
	pair<int, vector<pair<int,int>>> minSpanningTree(vector<Edge> v){
		int n = v.size();
		sort(v.begin(), v.end(), custom_compare_min);
		union_find sets(n);
		vector<pair<int,int>> output;
		
		int contador = 0;
		
		for (int i = 0; i < v.size(); i++){
			Edge nodo = v[i];
			if (sets.sameSet(nodo.n1, nodo.n2) == false){
				sets.unionSet(nodo.n1, nodo.n2);
				output.push_back({nodo.n1+1, nodo.n2+1});
				contador += nodo.w;
				if (output.size() == n-1) break;
			}
		}
		
		sort(output.begin(), output.end());
		
		return {contador, output};
	}
	
	pair<int, vector<pair<int,int>>> maxSpanningTree(vector<Edge> v){
		int n = v.size();
		sort(v.begin(), v.end(), custom_compare_max);
		union_find sets(n);
		vector<pair<int,int>> output;
		
		int contador = 0;
		
		for (int i = 0; i < v.size(); i++){
			Edge nodo = v[i];
			if (sets.sameSet(nodo.n1, nodo.n2) == false){
				sets.unionSet(nodo.n1, nodo.n2);
				output.push_back({nodo.n1+1, nodo.n2+1});
				contador += nodo.w;
				if (output.size() == n-1) break;
			}
		}
		
		sort(output.begin(), output.end());
		
		return {contador, output};
	}
	
	int main (){
		ios_base::sync_with_stdio (false);
		cin.tie(nullptr);
		
		int n;
		cin >> n;
		vector<Edge> v;
		
		for (int i = 0; i < n; i++){
			for (int j = 0; j < n; j++){
				int w;
				cin >> w;
				
				if (i < j && w != 0){ // Triangular superior sin diagonal
					Edge nodo;
					nodo.n1 = i;
					nodo.n2 = j;
					nodo.w = w;
					v.push_back(nodo);
				}
			}
		}
		cout << "Min ST Value: " << minSpanningTree(v).first << endl;
		for (auto c: minSpanningTree(v).second) cout << c.first << " " << c.second << endl ;
		
		cout << "Max ST Value: " << maxSpanningTree(v).first << endl;
		for (auto c: maxSpanningTree(v).second) cout << c.first << " " << c.second << endl ;
		
		return 0;
	}
\end{lstlisting}